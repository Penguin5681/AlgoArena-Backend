[
  {
    "title": "Two Sum",
    "slug": "two-sum",
    "description": "Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\n\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\n\nYou can return the answer in any order.",
    "topic": "Arrays",
    "difficulty": "easy",
    "constraints": [
      "2 <= nums.length <= 10^4",
      "-10^9 <= nums[i] <= 10^9",
      "-10^9 <= target <= 10^9",
      "Only one valid answer exists"
    ],
    "examples": [
      {
        "input": "nums = [2,7,11,15], target = 9",
        "output": "[0,1]"
      },
      {
        "input": "nums = [3,2,4], target = 6",
        "output": "[1,2]"
      },
      {
        "input": "nums = [3,3], target = 6",
        "output": "[0,1]"
      }
    ],
    "hints": [
      "A really brute force way would be to search for all possible pairs of numbers but that would be too slow. Again, it's best to try out brute force solutions for just for completeness. It is from these brute force solutions that you can come up with optimizations.",
      "So, if we fix one of the numbers, say x, we have to scan the entire array to find the next number y which is value - x where value is the input parameter. Can we change our array somehow so that this search becomes faster?",
      "The second train of thought is, without changing the array, can we use additional space somehow? Like maybe a hash map to speed up the search?"
    ],
    "time_complexity": "O(n)",
    "space_complexity": "O(n)"
  },
  {
    "title": "Valid Parentheses",
    "slug": "valid-parentheses",
    "description": "Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.\n\nAn input string is valid if:\n1. Open brackets must be closed by the same type of brackets.\n2. Open brackets must be closed in the correct order.\n3. Every close bracket has a corresponding open bracket of the same type.",
    "topic": "Stack",
    "difficulty": "easy",
    "constraints": [
      "1 <= s.length <= 10^4",
      "s consists of parentheses only '()[]{}'."
    ],
    "examples": [
      {
        "input": "s = \"()\"",
        "output": "true"
      },
      {
        "input": "s = \"()[]{}\"",
        "output": "true"
      },
      {
        "input": "s = \"(]\"",
        "output": "false"
      }
    ],
    "hints": [
      "Use a stack of characters.",
      "When you encounter an opening bracket, push it to the top of the stack.",
      "When you encounter a closing bracket, check if the top of the stack was the opening for it. If yes, pop it from the stack. Otherwise, return false."
    ],
    "time_complexity": "O(n)",
    "space_complexity": "O(n)"
  },
  {
    "title": "Merge Two Sorted Lists",
    "slug": "merge-two-sorted-lists",
    "description": "You are given the heads of two sorted linked lists list1 and list2.\n\nMerge the two lists in a one sorted list. The list should be made by splicing together the nodes of the first two lists.\n\nReturn the head of the merged linked list.",
    "topic": "Linked List",
    "difficulty": "easy",
    "constraints": [
      "The number of nodes in both lists is in the range [0, 50].",
      "-100 <= Node.val <= 100",
      "Both list1 and list2 are sorted in non-decreasing order."
    ],
    "examples": [
      {
        "input": "list1 = [1,2,4], list2 = [1,3,4]",
        "output": "[1,1,2,3,4,4]"
      },
      {
        "input": "list1 = [], list2 = []",
        "output": "[]"
      },
      {
        "input": "list1 = [], list2 = [0]",
        "output": "[0]"
      }
    ],
    "hints": [
      "Maintain a head pointer to the merged list.",
      "Compare values of the current nodes of both lists and attach the smaller one to the result.",
      "Don't forget to handle the remaining nodes when one list is exhausted."
    ],
    "time_complexity": "O(n + m)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Maximum Subarray",
    "slug": "maximum-subarray",
    "description": "Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.\n\nA subarray is a contiguous part of an array.",
    "topic": "Dynamic Programming",
    "difficulty": "medium",
    "constraints": [
      "1 <= nums.length <= 10^5",
      "-10^4 <= nums[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "nums = [-2,1,-3,4,-1,2,1,-5,4]",
        "output": "6"
      },
      {
        "input": "nums = [1]",
        "output": "1"
      },
      {
        "input": "nums = [5,4,-1,7,8]",
        "output": "23"
      }
    ],
    "hints": [
      "Try using Kadane's algorithm.",
      "At each position, you can either start a new subarray or extend the existing one.",
      "Keep track of the maximum sum seen so far."
    ],
    "time_complexity": "O(n)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Binary Tree Level Order Traversal",
    "slug": "binary-tree-level-order-traversal",
    "description": "Given the root of a binary tree, return the level order traversal of its nodes' values. (i.e., from left to right, level by level).",
    "topic": "Tree",
    "difficulty": "medium",
    "constraints": [
      "The number of nodes in the tree is in the range [0, 2000].",
      "-1000 <= Node.val <= 1000"
    ],
    "examples": [
      {
        "input": "root = [3,9,20,null,null,15,7]",
        "output": "[[3],[9,20],[15,7]]"
      },
      {
        "input": "root = [1]",
        "output": "[[1]]"
      },
      {
        "input": "root = []",
        "output": "[]"
      }
    ],
    "hints": [
      "Use BFS (Breadth-First Search) with a queue.",
      "Process nodes level by level by keeping track of the current level size.",
      "Add all nodes of the current level to the result before moving to the next level."
    ],
    "time_complexity": "O(n)",
    "space_complexity": "O(w)"
  },
  {
    "title": "Longest Increasing Subsequence",
    "slug": "longest-increasing-subsequence",
    "description": "Given an integer array nums, return the length of the longest strictly increasing subsequence.\n\nA subsequence is a sequence that can be derived from an array by deleting some or no elements without changing the order of the remaining elements.",
    "topic": "Dynamic Programming",
    "difficulty": "medium",
    "constraints": [
      "1 <= nums.length <= 2500",
      "-10^4 <= nums[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "nums = [10,9,2,5,3,7,101,18]",
        "output": "4"
      },
      {
        "input": "nums = [0,1,0,3,2,3]",
        "output": "4"
      },
      {
        "input": "nums = [7,7,7,7,7,7,7]",
        "output": "1"
      }
    ],
    "hints": [
      "Think about the brute force approach first. Can you optimize it using dynamic programming?",
      "For each element, what's the longest increasing subsequence ending at that element?",
      "Can you use binary search to optimize further?"
    ],
    "time_complexity": "O(n^2)",
    "space_complexity": "O(n)"
  },
  {
    "title": "Regular Expression Matching",
    "slug": "regular-expression-matching",
    "description": "Given an input string s and a pattern p, implement regular expression matching with support for '.' and '*' where:\n\n'.' Matches any single character.\n'*' Matches zero or more of the preceding element.\n\nThe matching should cover the entire input string (not partial).",
    "topic": "Dynamic Programming",
    "difficulty": "hard",
    "constraints": [
      "1 <= s.length <= 20",
      "1 <= p.length <= 30",
      "s contains only lowercase English letters.",
      "p contains only lowercase English letters, '.', and '*'.",
      "It is guaranteed for each appearance of the character '*', there will be a previous valid character to match."
    ],
    "examples": [
      {
        "input": "s = \"aa\", p = \"a\"",
        "output": "false"
      },
      {
        "input": "s = \"aa\", p = \"a*\"",
        "output": "true"
      },
      {
        "input": "s = \"ab\", p = \".*\"",
        "output": "true"
      }
    ],
    "hints": [
      "This problem has a typical solution using dynamic programming. We define the state P(i,j) to be true if s[0..i) matches p[0..j) and false otherwise.",
      "The state transitions have two cases: the general case and the special case with the '*' character.",
      "For the general case, we just check if the current characters match, and if they do, we move to the next state P(i+1, j+1)."
    ],
    "time_complexity": "O(n*m)",
    "space_complexity": "O(n*m)"
  },
  {
    "title": "Median of Two Sorted Arrays",
    "slug": "median-of-two-sorted-arrays",
    "description": "Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\n\nThe overall run time complexity should be O(log (m+n)).",
    "topic": "Binary Search",
    "difficulty": "hard",
    "constraints": [
      "nums1.length == m",
      "nums2.length == n",
      "0 <= m <= 1000",
      "0 <= n <= 1000",
      "1 <= m + n <= 2000",
      "-10^6 <= nums1[i], nums2[i] <= 10^6"
    ],
    "examples": [
      {
        "input": "nums1 = [1,3], nums2 = [2]",
        "output": "2.00000"
      },
      {
        "input": "nums1 = [1,2], nums2 = [3,4]",
        "output": "2.50000"
      }
    ],
    "hints": [
      "To solve this problem, we need to understand \"What is the use of median\". In statistics, the median is used for dividing a set into two equal length subsets, that one subset is always greater than the other.",
      "If we understand the use of median for dividing, we are very close to the answer.",
      "First let's cut A into two parts at a random position i: left_A[0, i-1] | right_A[i, m-1]. Since A has m elements, so there are m+1 kinds of cutting (i = 0 ~ m)."
    ],
    "time_complexity": "O(log(min(m,n)))",
    "space_complexity": "O(1)"
  },
  {
    "title": "Climbing Stairs",
    "slug": "climbing-stairs",
    "description": "You are climbing a staircase. It takes n steps to reach the top.\n\nEach time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?",
    "topic": "Dynamic Programming",
    "difficulty": "easy",
    "constraints": [
      "1 <= n <= 45"
    ],
    "examples": [
      {
        "input": "n = 2",
        "output": "2"
      },
      {
        "input": "n = 3",
        "output": "3"
      }
    ],
    "hints": [
      "To reach nth step, what could have been your previous steps? (Think about the step sizes)",
      "You are climbing either from (n-1)th step or (n-2)th step.",
      "So the number of ways to get to the nth step is equal to the sum of ways of getting to the (n-1)th step and ways of getting to the (n-2)th step."
    ],
    "time_complexity": "O(n)",
    "space_complexity": "O(1)"
  },
  {
    "title": "Best Time to Buy and Sell Stock",
    "slug": "best-time-to-buy-and-sell-stock",
    "description": "You are given an array prices where prices[i] is the price of a given stock on the ith day.\n\nYou want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.\n\nReturn the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.",
    "topic": "Arrays",
    "difficulty": "easy",
    "constraints": [
      "1 <= prices.length <= 10^5",
      "0 <= prices[i] <= 10^4"
    ],
    "examples": [
      {
        "input": "prices = [7,1,5,3,6,4]",
        "output": "5"
      },
      {
        "input": "prices = [7,6,4,3,1]",
        "output": "0"
      }
    ],
    "hints": [
      "Say the given array is [7, 1, 5, 3, 6, 4]. If we plot the numbers of the given array on a graph, we get: The points of interest are the peaks and valleys in the given graph. We need to find the largest peak following the smallest valley.",
      "We can maintain two variables - minprice and maxprofit corresponding to the smallest valley and maximum profit (maximum difference between selling price and minprice) obtained so far respectively."
    ],
    "time_complexity": "O(n)",
    "space_complexity": "O(1)"
  }
]